{
  "hash": "43f7818c83338fd103666530b97b62d0",
  "result": {
    "markdown": "---\ntitle: \"2: Spatial Weights, GLSA & EHSA\"\nauthor: \"Magdalene Chan\"\ndate: 2023-11-25\ndate-modified: \"last-modified\"\nexecute: \n  warning: false\n---\n\n\n# Getting Started\n\nThe code chunk below uses p_load() of pacman package to check if the required packages have been installed on the computer. If they are, the packages will be launched.\n\n-   **sf** package is used for importing, managing, and processing geospatial data.\n-   **tmap** package is used for thematic mapping.\n-   **sfdep** package is used to create spatial weights matrix and LISA objects using the `sf` class to represent spatial data.\n-   **plotly** package is used to create interactive graphs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, plotly, tidyverse, knitr)\n```\n:::\n\n\n# Spatial Weights\n\nThe data sets used are:\n\n-   Hunan county boundary layer: a geospatial data set in ESRI shapefile format.\n-   Hunan_2012.csv: csv file that contains selected Hunan's local development indicators in 2012.\n\n## Importing Data\n\n### Import shapefile into R\n\nThe code chunk below uses the `st_read()` function of **sf** package to import Hunan county boundary shapefile into R as a simple feature data frame called `hunan`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\magdalenecjw\\ISSS624 Geospatial\\In_Class_Exercise\\Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nThere are a total of 88 polygon features and 7 fields in `hunan` simple feature data frame. `hunan` is in **wgs84** GCS.\n\n### Import aspatial data into R\n\nThe code chunk below uses the `read_csv()` function of **readr** package to import `Hunan_2012.csv` file into R and save it as a R dataframe called `hunan2012`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n### Performing relational join\n\n`left_join()` of **dplyr** is used to join the geographical data and attribute table using `County` as the common identifier. Left join is done to ensure that the geospatial properties (`geometry` column) of the `hunan` sf data frame is retained. After the join, a pipe operation is done to further select only the required columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012)%>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n## Plot choropleth map\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hunan) +\n  tm_fill(\"GDPPC\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"GDPPC\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Distribution of GDP per capita by district, Hunan Province\",\n            main.title.position = \"center\",\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n```\n\n::: {.cell-output-display}\n![](In_Class_Ex2_files/figure-html/unnamed-chunk-5-1.png){width=864}\n:::\n:::\n\n\n## Deriving Contiguity Spatial Weights\n\n### Identify contiguity neighbours: Queen method\n\nThe code chunk below computes contiguity based neighbours based on the Queen criterion using tidy method and **sfdep** package (instead of **spdep** package). \n\n> In both packages, the `queen` argument takes `TRUE` (default) or `FALSE` as options. The `queen` argument is not specified in the code chunk below, hence, the default value of `TRUE` will be used. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q <- hunan %>%\n  mutate(nb = st_contiguity(geometry), .before=1)\n```\n:::\n\n\nThe code chunk below is used to print the summary of the first lag neighbour list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nb_q$nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan province. The most connected area unit has 11 neighbours. There are two are units with only one neighbour.\n\nView the content of the data tables using the code chunk below. \n\n> Using **sfdep** instead of **spdep** gives an output that is a sf tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(nb_q, n=10))\n```\n\n::: {.cell-output-display}\n|nb                             |NAME_2   |  ID_3|NAME_3    |ENGTYPE_3   |County    | GDPPC|geometry                       |\n|:------------------------------|:--------|-----:|:---------|:-----------|:---------|-----:|:------------------------------|\n|2, 3, 4, 57, 85                |Changde  | 21098|Anxiang   |County      |Anxiang   | 23667|POLYGON ((112.0625 29.75523... |\n|1, 57, 58, 78, 85              |Changde  | 21100|Hanshou   |County      |Hanshou   | 20981|POLYGON ((112.2288 29.11684... |\n|1, 4, 5, 85                    |Changde  | 21101|Jinshi    |County City |Jinshi    | 34592|POLYGON ((111.8927 29.6013,... |\n|1, 3, 5, 6                     |Changde  | 21102|Li        |County      |Li        | 24473|POLYGON ((111.3731 29.94649... |\n|3, 4, 6, 85                    |Changde  | 21103|Linli     |County      |Linli     | 25554|POLYGON ((111.6324 29.76288... |\n|4, 5, 69, 75, 85               |Changde  | 21104|Shimen    |County      |Shimen    | 27137|POLYGON ((110.8825 30.11675... |\n|67, 71, 74, 84                 |Changsha | 21109|Liuyang   |County City |Liuyang   | 63118|POLYGON ((113.9905 28.5682,... |\n|9, 46, 47, 56, 78, 80, 86      |Changsha | 21110|Ningxiang |County      |Ningxiang | 62202|POLYGON ((112.7181 28.38299... |\n|8, 66, 68, 78, 84, 86          |Changsha | 21111|Wangcheng |County      |Wangcheng | 70666|POLYGON ((112.7914 28.52688... |\n|16, 17, 19, 20, 22, 70, 72, 73 |Chenzhou | 21112|Anren     |County      |Anren     | 12761|POLYGON ((113.1757 26.82734... |\n:::\n:::\n\n\nThe table above shows that polygon 1 has five neighbours. They are polygons number 2, 3, 4, 57,and 85.\n\n### Identify contiguity neighbours: Rook method\n\nThe code chunk below computes contiguity based neighbours based on the Rook criterion using the **sfdept** package. \n\n> The `queen` argument is now set to `FALSE` to compute based on the Rook criterion. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_r <- hunan %>%\n  mutate(nb = st_contiguity(geometry, queen = FALSE), .before=1)\n```\n:::\n\n\nThe code chunk below is used to print the summary of the first lag neighbour list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nb_q$nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan province. The most connected area unit has 11 neighbours. There are two are units with only one neighbour.\n\nView the content of the data tables using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(nb_r, n=10))\n```\n\n::: {.cell-output-display}\n|nb                         |NAME_2   |  ID_3|NAME_3    |ENGTYPE_3   |County    | GDPPC|geometry                       |\n|:--------------------------|:--------|-----:|:---------|:-----------|:---------|-----:|:------------------------------|\n|3, 4, 57, 85               |Changde  | 21098|Anxiang   |County      |Anxiang   | 23667|POLYGON ((112.0625 29.75523... |\n|57, 58, 78, 85             |Changde  | 21100|Hanshou   |County      |Hanshou   | 20981|POLYGON ((112.2288 29.11684... |\n|1, 4, 5, 85                |Changde  | 21101|Jinshi    |County City |Jinshi    | 34592|POLYGON ((111.8927 29.6013,... |\n|1, 3, 5, 6                 |Changde  | 21102|Li        |County      |Li        | 24473|POLYGON ((111.3731 29.94649... |\n|3, 4, 6, 85                |Changde  | 21103|Linli     |County      |Linli     | 25554|POLYGON ((111.6324 29.76288... |\n|4, 5, 69, 75, 85           |Changde  | 21104|Shimen    |County      |Shimen    | 27137|POLYGON ((110.8825 30.11675... |\n|67, 71, 74, 84             |Changsha | 21109|Liuyang   |County City |Liuyang   | 63118|POLYGON ((113.9905 28.5682,... |\n|9, 46, 47, 56, 78, 80, 86  |Changsha | 21110|Ningxiang |County      |Ningxiang | 62202|POLYGON ((112.7181 28.38299... |\n|8, 66, 68, 78, 84, 86      |Changsha | 21111|Wangcheng |County      |Wangcheng | 70666|POLYGON ((112.7914 28.52688... |\n|16, 19, 20, 22, 70, 72, 73 |Chenzhou | 21112|Anren     |County      |Anren     | 12761|POLYGON ((113.1757 26.82734... |\n:::\n:::\n\n\nThe table above shows that polygon 1 has four neighbours. They are polygons number 3, 4, 57,and 85.\n\n### Identifying higher order neighbours\n\nTo identify higher order contiguity neighbours, use `st_nb_lag_cumul()` as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb2_queen <-  hunan %>% \n  mutate(nb = st_contiguity(geometry),\n         nb2 = st_nb_lag_cumul(nb, 2),\n         .before = 1)\n```\n:::\n\n\nNote that if the order is 2, the result contains both 1st and 2nd order neighbors as shown on the print below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb2_queen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 88 features and 8 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 10 features:\n                               nb\n1                 2, 3, 4, 57, 85\n2               1, 57, 58, 78, 85\n3                     1, 4, 5, 85\n4                      1, 3, 5, 6\n5                     3, 4, 6, 85\n6                4, 5, 69, 75, 85\n7                  67, 71, 74, 84\n8       9, 46, 47, 56, 78, 80, 86\n9           8, 66, 68, 78, 84, 86\n10 16, 17, 19, 20, 22, 70, 72, 73\n                                                                                        nb2\n1                                     2, 3, 4, 5, 6, 32, 56, 57, 58, 64, 69, 75, 76, 78, 85\n2                           1, 3, 4, 5, 6, 8, 9, 32, 56, 57, 58, 64, 68, 69, 75, 76, 78, 85\n3                                                 1, 2, 4, 5, 6, 32, 56, 57, 69, 75, 78, 85\n4                                                             1, 2, 3, 5, 6, 57, 69, 75, 85\n5                                                 1, 2, 3, 4, 6, 32, 56, 57, 69, 75, 78, 85\n6                                         1, 2, 3, 4, 5, 32, 53, 55, 56, 57, 69, 75, 78, 85\n7                                                     9, 19, 66, 67, 71, 73, 74, 76, 84, 86\n8  2, 9, 19, 21, 31, 32, 34, 35, 36, 41, 45, 46, 47, 56, 58, 66, 68, 74, 78, 80, 84, 85, 86\n9               2, 7, 8, 19, 21, 35, 46, 47, 56, 58, 66, 67, 68, 74, 76, 78, 80, 84, 85, 86\n10               11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 70, 71, 72, 73, 74, 82, 83, 86\n     NAME_2  ID_3    NAME_3   ENGTYPE_3    County GDPPC\n1   Changde 21098   Anxiang      County   Anxiang 23667\n2   Changde 21100   Hanshou      County   Hanshou 20981\n3   Changde 21101    Jinshi County City    Jinshi 34592\n4   Changde 21102        Li      County        Li 24473\n5   Changde 21103     Linli      County     Linli 25554\n6   Changde 21104    Shimen      County    Shimen 27137\n7  Changsha 21109   Liuyang County City   Liuyang 63118\n8  Changsha 21110 Ningxiang      County Ningxiang 62202\n9  Changsha 21111 Wangcheng      County Wangcheng 70666\n10 Chenzhou 21112     Anren      County     Anren 12761\n                         geometry\n1  POLYGON ((112.0625 29.75523...\n2  POLYGON ((112.2288 29.11684...\n3  POLYGON ((111.8927 29.6013,...\n4  POLYGON ((111.3731 29.94649...\n5  POLYGON ((111.6324 29.76288...\n6  POLYGON ((110.8825 30.11675...\n7  POLYGON ((113.9905 28.5682,...\n8  POLYGON ((112.7181 28.38299...\n9  POLYGON ((112.7914 28.52688...\n10 POLYGON ((113.1757 26.82734...\n```\n:::\n:::\n\n\n### Compute contiguity weights: Queen method\n\nCompute the contiguity weights by using `st_weights()` of **sfdep** package. In the code chunk below, Queen method is used to derive the contiguity weights.\n\n> In the **spdep** package, the weights matrix can be retrieved together with the neighbour list from the `poly2nb()` argument. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb, style = \"W\"),\n         .before = 1) \n```\n:::\n\n\n`st_weights()` takes in three arguments:\n\n-   `nb`: A neighbor list object as created by `st_neighbors()`.\n-   `style`: Default `“W”` for row standardized weights. This value can also be `“B”` (basic binary coding), `“C”` (globally standardised, or sums over all links to n), `“U”` (C divided by the number of neighbours, or sums over all links to unity), `“minmax”`, and `“S”` (the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168, or sums over all links to n).\n-   `allow_zero`: If `TRUE`, assigns zero as lagged value to zone without neighbors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 88 features and 8 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 10 features:\n                               nb\n1                 2, 3, 4, 57, 85\n2               1, 57, 58, 78, 85\n3                     1, 4, 5, 85\n4                      1, 3, 5, 6\n5                     3, 4, 6, 85\n6                4, 5, 69, 75, 85\n7                  67, 71, 74, 84\n8       9, 46, 47, 56, 78, 80, 86\n9           8, 66, 68, 78, 84, 86\n10 16, 17, 19, 20, 22, 70, 72, 73\n                                                                            wt\n1                                                      0.2, 0.2, 0.2, 0.2, 0.2\n2                                                      0.2, 0.2, 0.2, 0.2, 0.2\n3                                                       0.25, 0.25, 0.25, 0.25\n4                                                       0.25, 0.25, 0.25, 0.25\n5                                                       0.25, 0.25, 0.25, 0.25\n6                                                      0.2, 0.2, 0.2, 0.2, 0.2\n7                                                       0.25, 0.25, 0.25, 0.25\n8  0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571\n9             0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667\n10                      0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125\n     NAME_2  ID_3    NAME_3   ENGTYPE_3    County GDPPC\n1   Changde 21098   Anxiang      County   Anxiang 23667\n2   Changde 21100   Hanshou      County   Hanshou 20981\n3   Changde 21101    Jinshi County City    Jinshi 34592\n4   Changde 21102        Li      County        Li 24473\n5   Changde 21103     Linli      County     Linli 25554\n6   Changde 21104    Shimen      County    Shimen 27137\n7  Changsha 21109   Liuyang County City   Liuyang 63118\n8  Changsha 21110 Ningxiang      County Ningxiang 62202\n9  Changsha 21111 Wangcheng      County Wangcheng 70666\n10 Chenzhou 21112     Anren      County     Anren 12761\n                         geometry\n1  POLYGON ((112.0625 29.75523...\n2  POLYGON ((112.2288 29.11684...\n3  POLYGON ((111.8927 29.6013,...\n4  POLYGON ((111.3731 29.94649...\n5  POLYGON ((111.6324 29.76288...\n6  POLYGON ((110.8825 30.11675...\n7  POLYGON ((113.9905 28.5682,...\n8  POLYGON ((112.7181 28.38299...\n9  POLYGON ((112.7914 28.52688...\n10 POLYGON ((113.1757 26.82734...\n```\n:::\n:::\n\n\n## Distance-based weights\n\nThere are three popularly used distance-based spatial weights, they are:\n\n- fixed distance weights,\n- adaptive distance weights, and\n- inverse distance weights (IDW).\n\n### Deriving fixed distance weights\n\nBefore deriving the fixed distance weights, determine the upper limit for distance band by using the steps below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo <- sf::st_geometry(hunan)\nnb <- st_knn(geo, longlat = TRUE)\ndists <- unlist(st_nb_dists(geo, nb))\n```\n:::\n\n\n> `st_nb_dists()` of **sfdep** is used to calculate the nearest neighbour distance. The output is a list of distances for each observation’s neighbors list.\n> `unlist()` of Base R is then used to return the output as a vector so that the summary statistics of the nearest neighbour distances can be derived.\n\nNext, derive summary statistics of the nearest neighbour distances vector (i.e. dists) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  21.56   29.11   36.89   37.34   43.21   65.80 \n```\n:::\n:::\n\n\nThe summary statistics report above shows that the maximum nearest neighbour distance is 65.80km. By using a threshold value of 66km will ensure that each area will have at least one neighbour. \n\nNext, compute the fixed distance weights by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_fd <- hunan %>%\n  mutate(nb = st_dist_band(geometry, upper = 66),\n               wt = st_weights(nb),\n               .before = 1)\n```\n:::\n\n\n> `st_dists_band()` of **sfdep** is used to identify neighbors based on a distance band (i.e. 66km). The output is a list of neighbours (i.e. nb).\n> `st_weights()` is then used to calculate polygon spatial weights of the nb list. Note that: (1) the default style argument is set to `“W”` for row standardized weights, and\nthe default `allow_zero` is set to `TRUE`, which assigns zero as lagged value to zone without neighbors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(wm_fd, n=10))\n```\n\n::: {.cell-output-display}\n|nb                     |wt                                                               |NAME_2   |  ID_3|NAME_3    |ENGTYPE_3   |County    | GDPPC|geometry                       |\n|:----------------------|:----------------------------------------------------------------|:--------|-----:|:---------|:-----------|:---------|-----:|:------------------------------|\n|2, 3, 4, 5, 57, 64     |0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667 |Changde  | 21098|Anxiang   |County      |Anxiang   | 23667|POLYGON ((112.0625 29.75523... |\n|1, 57, 58, 78, 85      |0.2, 0.2, 0.2, 0.2, 0.2                                          |Changde  | 21100|Hanshou   |County      |Hanshou   | 20981|POLYGON ((112.2288 29.11684... |\n|1, 4, 5, 57            |0.25, 0.25, 0.25, 0.25                                           |Changde  | 21101|Jinshi    |County City |Jinshi    | 34592|POLYGON ((111.8927 29.6013,... |\n|1, 3, 5, 6             |0.25, 0.25, 0.25, 0.25                                           |Changde  | 21102|Li        |County      |Li        | 24473|POLYGON ((111.3731 29.94649... |\n|1, 3, 4, 6, 69         |0.2, 0.2, 0.2, 0.2, 0.2                                          |Changde  | 21103|Linli     |County      |Linli     | 25554|POLYGON ((111.6324 29.76288... |\n|4, 5, 69               |0.3333333, 0.3333333, 0.3333333                                  |Changde  | 21104|Shimen    |County      |Shimen    | 27137|POLYGON ((110.8825 30.11675... |\n|67, 71, 84             |0.3333333, 0.3333333, 0.3333333                                  |Changsha | 21109|Liuyang   |County City |Liuyang   | 63118|POLYGON ((113.9905 28.5682,... |\n|9, 46, 47, 78, 80      |0.2, 0.2, 0.2, 0.2, 0.2                                          |Changsha | 21110|Ningxiang |County      |Ningxiang | 62202|POLYGON ((112.7181 28.38299... |\n|8, 46, 66, 68, 84, 86  |0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667 |Changsha | 21111|Wangcheng |County      |Wangcheng | 70666|POLYGON ((112.7914 28.52688... |\n|16, 20, 22, 70, 72, 73 |0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667 |Chenzhou | 21112|Anren     |County      |Anren     | 12761|POLYGON ((113.1757 26.82734... |\n:::\n:::\n\n\n### Deriving adaptive distance weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_ad <- hunan %>% \n  mutate(nb = st_knn(geometry,\n                     k=8),\n         wt = st_weights(nb),\n               .before = 1)\n```\n:::\n\n\n> `st_knn()` of **sfdep** is used to identify neighbors based on k (i.e. `k = 8` indicates the nearest eight neighbours). The output is a list of neighbours (i.e. `nb`).\n> `st_weights()` is then used to calculate polygon spatial weights of the nb list. Note that: (1) the default style argument is set to `“W”` for row standardized weights, and\nthe default `allow_zero` is set to `TRUE`, which assigns zero as lagged value to zone without neighbors.\n\n### Deriving inverse distance weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan %>%\n  mutate(nb = st_contiguity(geometry),\n         wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1),\n         .before = 1)\n```\n:::\n\n\n> `st_contiguity()` of **sfdep** is used to identify the neighbours by using contiguity criteria. The output is a list of neighbours (i.e. `nb`).\n> `st_inverse_distance()` is then used to calculate inverse distance weights of neighbours on the `nb` list.\n\n:::callout-note\n\n#### Learnings from the above exercise\n\n**sfdep** package can be used to perform the same spatial weights computations as **spdep** package, but with additional functionalities and has a sf and tidyverse friendly interface to the package. There is also a mapping of the functions in **sfdep** against that of **spdep** in the [documentation](https://sfdep.josiahparry.com/articles/spdep-and-pysal). \n\n:::\n\n# Global & Local Measures of Spatial Autocorrelation (GLSA)\n\n## Computing Global Moran's I\n\nIn the code chunk below, `global_moran()` function is used to compute the Moran’s I value. Different from **spdep** package, the output is a tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n:::\n:::\n\n\nIn general, Moran’s I test will be performed instead of just computing the Moran’s I statistics. With sfdep package, Moran’s I test can be performed by using `global_moran_test() `as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\n> The default for `alternative` argument is `“two.sided”`. Other supported arguments are `“greater”` or `“less”`.\n> The default for `randomization` argument is `TRUE`. If `FALSE`, there is an assumption of normality.\n\n## Performing Global Moran's I Permutation test\n\nIn practice, monte carlo simulation should be used to perform the statistical test. For **sfdep**, it is supported by `globel_moran_perm()`. It is always a good practice to use `set.seed()` before performing simulation to ensure that the computation is reproducible.\n\n> The numbers of simulation is alway equal to `nsim` + 1. This mean that if `nsim = 99`, 100 simulations will be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nglobal_moran_perm(wm_q$GDPPC, wm_q$nb, wm_q$wt, nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n:::\n\n\nThe report above show that the p-value is smaller than alpha value of 0.05. Hence, reject the null hypothesis that the spatial patterns spatial independent. Because the Moran’s I statistics is greater than 0, it can be inferred that the spatial distribution shows sign of clustering.\n\n## Computing Local Moran's I\n\nCompute local Moran's I of GDPPC at county level by using `local_moran()` of **sfdep** package. \n\n> `unnest()` of **tidyr** package is used to expand a list-column containing data frames into rows and columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(GDPPC, nb, wt, nsim = 99),\n         .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\n## Visualising Local Moran's I and p-values of Local Moran's I\n\nIn this code chunk below, **tmap** functions are used prepare a choropleth map using values in the `ii` and `p_ii` fields.\n\n> For p-values, the appropriate classification should be 0.001, 0.01, 0.05 and not significant instead of using default classification scheme.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\", palette = \"Blues\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"local Moran's I of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(lisa) +\n  tm_fill(\"p_ii\", palette = \"-Greys\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n          labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of local Moran's I\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In_Class_Ex2_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Visualising LISA map\n\nLISA map is a categorical map showing outliers and clusters. There are two types of outliers namely: High-Low and Low-High outliers. Likewise, there are two type of clusters namely: High-High and Low-Low clusters. \n\n> LISA map is an interpreted map by combining local Moran’s I of geographical areas and their respective p-values.\n\nIn `lisa` sf data.frame, there are three fields containing the LISA categories. They are `mean`, `median` and `pysal.` In general, classification in mean will be used as shown in the code chunk below.\n\n> If the distribution is skewed, it is not advisable to use mean.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa  %>%\n  filter(p_ii < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") + \n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In_Class_Ex2_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n# Emerging Hot Spot Analysis (EHSA)\n\nThe data sets used are:\n\n-   Hunan county boundary layer: a geospatial data set in ESRI shapefile format (already loaded).\n-   Hunan_GDPPC.csv: csv file that contains Hunan's local GDPPC from 2005 to 2021.\n\n## Importing Data\n\n### Import aspatial data into R\n\nThe code chunk below uses the `read_csv()` function of **readr** package to import `Hunan_GDPPC.csv` file into R and save it as a R dataframe called `hunan_gdppc`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC <- read_csv(\"data/aspatial/Hunan_GDPPC.csv\")\n```\n:::\n\n\n### Create a Time Series Cube\n\nThe code chunk below creates a time-space cube (spacetime cube) using `spacetime()` of **sfdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC_st <- spacetime(GDPPC, hunan, .loc_col = \"County\", .time_col = \"Year\")\n```\n:::\n\n\nThe code chunk below checks that the time series cube has been created correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(GDPPC_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThe `TRUE` return confirms that `GDPPC_st` object is indeed a time-space cube.\n\n### Derive spatial weights\n\nThe code chunk below will be used to identify neighbours and to derive an inverse distance weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC_nb <- GDPPC_st %>%\n  activate(\"geometry\") %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wt = st_inverse_distance(nb, geometry, scale = 1, alpha = 1),\n         .before = 1) %>%\n  set_nbs(\"nb\") %>%\n  set_wts(\"wt\")\n\nhead(GDPPC_nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   Year County  GDPPC nb        wt       \n  <dbl> <chr>   <dbl> <list>    <list>   \n1  2005 Anxiang  8184 <int [6]> <dbl [6]>\n2  2005 Hanshou  6560 <int [6]> <dbl [6]>\n3  2005 Jinshi   9956 <int [5]> <dbl [5]>\n4  2005 Li       8394 <int [5]> <dbl [5]>\n5  2005 Linli    8850 <int [5]> <dbl [5]>\n6  2005 Shimen   9244 <int [6]> <dbl [6]>\n```\n:::\n:::\n\n\n> `activate()` of **dplyr** package is used to activate the geometry context.\n> `mutate()` of **dplyr** package is used to create two new columns `nb` and `wt`. \n> Then activate the data context again and copy over the `nb` and `wt` columns to each time-slice using `set_nbs()` and `set_wts()`.\n> Row order is very important so do not rearrange the observations after using `set_nbs()` or `set_wts()`.\n\nThe dataset now has neighbors and weights for each time-slice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(GDPPC_nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   Year County  GDPPC nb        wt       \n  <dbl> <chr>   <dbl> <list>    <list>   \n1  2005 Anxiang  8184 <int [6]> <dbl [6]>\n2  2005 Hanshou  6560 <int [6]> <dbl [6]>\n3  2005 Jinshi   9956 <int [5]> <dbl [5]>\n4  2005 Li       8394 <int [5]> <dbl [5]>\n5  2005 Linli    8850 <int [5]> <dbl [5]>\n6  2005 Shimen   9244 <int [6]> <dbl [6]>\n```\n:::\n:::\n\n\n### Computing G~i~\\*\n\nThe new columns are then used to manually compute the local G~i~\\* for each location by grouping `Year` and using `local_gstar_perm()` of **sfdep** package. After which, use `unnest()` to unnest `gi_star` column of the newly created `gi_stars` data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngi_stars <- GDPPC_nb %>%\n  group_by(Year) %>%\n  mutate(gi_star = local_gstar_perm(GDPPC, nb, wt)) %>%\n  tidyr::unnest(gi_star)\n```\n:::\n\n\n### Perform Emerging Hotspot Analysis\n\nPerform EHSA analysis by using `emerging_hotspot_analysis()` of **sfdep** package. It takes a spacetime object (i.e. `GDPPC_st`), and the quoted name of the variable of interest (i.e. `GDPPC`) for `.var` argument. The `k` argument is used to specify the number of time lags which is set to 1 by default. Lastly, `nsim` defines the number of simulations to be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa <- emerging_hotspot_analysis(x = GDPPC_st, \n                                  .var = \"GDPPC\", \n                                  k = 1, \n                                  nsim = 99)\n```\n:::\n\n\n### Visualising the distribution of EHSA classes\n\nIn the code chunk below, **ggplot2** functions are used to reveal the distribution of EHSA classes as a bar chart.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = ehsa,\n       aes(x = classification)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](In_Class_Ex2_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nFigure above shows that the \"sporadic cold spots\" class has the highest count of counties.\n\n### Visualising EHSA\n\nBefore visualising the geographic distribution EHSA classes, the data frames `hunan` and `ehsa` must be joined together by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_ehsa <- hunan %>%\n  left_join(ehsa, by = c(\"County\" = \"location\"))\n```\n:::\n\n\nNext, **tmap** functions will be used to plot a categorical choropleth map by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nehsa_sig <- hunan_ehsa  %>%\n  filter(p_value < 0.05)\ntmap_mode(\"plot\")\ntm_shape(hunan_ehsa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(ehsa_sig) +\n  tm_fill(\"classification\") + \n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In_Class_Ex2_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::",
    "supporting": [
      "In_Class_Ex2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}