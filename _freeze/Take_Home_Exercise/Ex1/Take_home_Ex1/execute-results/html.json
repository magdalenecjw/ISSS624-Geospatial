{
  "hash": "253b1e30bf0145ec0c3e824fccfedb50",
  "result": {
    "markdown": "---\ntitle: \"1: Geospatial Analytics for Public Good\"\nauthor: \"Magdalene Chan\"\ndate: 2023-11-25\ndate-modified: \"last-modified\"\nexecute: \n  warning: false\nformat: \n  html:\n    code-fold: true\n    code-summary: \"Show code\"\n---\n\n\n# Objectives\n\nAs city-wide urban infrastructures become increasingly digital, datasets from technologies like GPS and RFID on vehicles offer opportunities to track movement patterns over space and time. For instance, smart cards and GPS devices on public buses collect routes and ridership data, containing valuable structure and patterns for understanding human movement and behavior within cities. Despite their potential, the practical use of these extensive location-aware datasets often remains limited to basic tracking and mapping within GIS applications due to the lack of comprehensive spatial and spatio-temporal analysis functions in conventional GIS tools.\n\nExploratory Spatial Data Analysis (ESDA) holds tremendous potential to address such complex problems. In this study, appropriate Local Indicators of Spatial Association (GLISA) and Emerging Hot Spot Analysis (EHSA) will be applied to undercover the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.\n\n# Tasks\n\nThe following tasks will be undertaken in this exercise:\n\n## Geovisualisation and Analysis\n\n1.  Compute the passenger trips generated by origin at a hexagon level of 250m for the following time periods:\n    1.  Weekday morning peak -- 6am to 9am (inclusive)\n    2.  Weekday evening peak -- 5pm to 8pm (inclusive)\n    3.  Weekend/holiday morning peak -- 11am to 2pm (inclusive)\n    4.  Weekend/holiday evening peak -- 4pm to 7pm (inclusive)\n2.  Display the geographical distribution of the passenger trips using appropriate geovisualisation methods.\n3.  Describe the spatial patterns revealed by the geovisualisation (not more than 200 words per visual).\n\n## Local Indicators of Spatial Association (LISA) Analysis\n\n1.  Compute LISA of the passengers trips generate by origin at hexagon level.\n2.  Display the LISA maps of the passengers trips generate by origin at hexagon level. The maps should only display the significant (i.e. p-value \\< 0.05).\n3.  With reference to the analysis results, draw statistical conclusions (not more than 200 words per visual).\n\n# Getting Started\n\nThe code chunk below uses `p_load()` of `pacman` package to check if the required packages have been installed on the computer. If they are, the packages will be launched.\n\n-   `sf` package is used for importing, managing, and processing geospatial data.\n-   `tmap` package is used for thematic mapping.\n-   `sfdep` package is used to create spatial weights matrix and LISA objects using the sf class to represent spatial data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse, knitr)\n```\n:::\n\n\nThe data sets used are:\n\n-   Bus Stop Location (Last updated Jul 2023) from [LTADataMall](https://datamall.lta.gov.sg/content/datamall/en/static-data.html) retrieved on 18 Nov 2023\n-   Passenger Volume by Origin Destination Bus Stops for Aug-Oct 2023 from [LTADataMall](https://datamall.lta.gov.sg/content/datamall/en/dynamic-data.html) retrieved on 18 Nov 2023\n\n# Import Data\n\n## Import Geospatial Data: Bus Stop Locations\n\nThe code chunk below uses the `st_read()` function of **sf** package to import `BusStop` shapefile into R as a simple feature data frame called `BusStop`. As `BusStop` uses **svy21** projected coordinate system, the `crs` is set to 3414.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBusStop <- st_read(dsn = \"data/geospatial\", \n                layer = \"BusStop\") %>%\n  st_transform(crs=3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `BusStop' from data source \n  `C:\\magdalenecjw\\ISSS624 Geospatial\\Take_Home_Exercise\\Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5161 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48284.56 ymax: 52983.82\nProjected CRS: SVY21\n```\n:::\n:::\n\n\n## Import Passenger Volume by Origin-Destination Bus Stops\n\nThe code chunk below uses the `read_csv()` function of `readr` package (imported with the `tidyverse` package) to import the csv files into R. A list called `list_of_data` is created and each CSV file is imported into a separate data frame within this list. The names of the data frames are generated dynamically based on the file names i.e. by extracting the month-year part of the csv file name. Finally, to access the data frames within the `list_of_data` without explicitly assigning them to new variables, the `list2env()` function in R is used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a list to store the data frames\nfile_names <- c(\"origin_destination_bus_202308.csv\", \n                \"origin_destination_bus_202309.csv\", \n                \"origin_destination_bus_202310.csv\")\nlist_of_data <- list()\n\n# Load CSV files into R environment\nfor (i in 1:length(file_names)) {\n  file_name <- file_names[i]\n  df_name <- paste0(\"odbus_\", \n                    substr(file_name, nchar(file_name) - 9, \n                           nchar(file_name) - 4))\n  list_of_data[[df_name]] <- read.csv(paste0(\"data/aspatial/\", file_name))\n}\n\n# Convert list elements to separate data frames in the global environment\nlist2env(list_of_data, envir = .GlobalEnv)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n\n```{.r .cell-code}\n# Remove the `list_of_data` data frame\nrm(list_of_data)\n```\n:::\n\n\nExamine the structure of the data frames using the code chunks below.\n\n::: panel-tabset\n### August 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(odbus_202308)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5709512 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-08\" \"2023-08\" \"2023-08\" \"2023-08\" ...\n $ DAY_TYPE           : chr  \"WEEKDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  16 16 14 14 17 17 17 17 7 17 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : int  4168 4168 80119 80119 44069 44069 20281 20281 19051 11169 ...\n $ DESTINATION_PT_CODE: int  10051 10051 90079 90079 17229 17229 20141 20141 10017 4219 ...\n $ TOTAL_TRIPS        : int  7 2 3 10 5 4 3 22 3 3 ...\n```\n:::\n:::\n\n\n### September 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(odbus_202309)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5714196 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-09\" \"2023-09\" \"2023-09\" \"2023-09\" ...\n $ DAY_TYPE           : chr  \"WEEKENDS/HOLIDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  17 10 10 7 7 11 16 16 16 20 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : int  24499 65239 65239 23519 23519 52509 3151 54349 54349 43371 ...\n $ DESTINATION_PT_CODE: int  22221 65159 65159 23311 23311 42041 11161 53241 53241 14139 ...\n $ TOTAL_TRIPS        : int  1 9 2 6 1 2 18 3 2 1 ...\n```\n:::\n:::\n\n\n### October 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(odbus_202310)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5694297 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-10\" \"2023-10\" \"2023-10\" \"2023-10\" ...\n $ DAY_TYPE           : chr  \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  16 16 14 14 17 17 17 7 14 14 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : int  4168 4168 80119 80119 44069 20281 20281 19051 81049 81049 ...\n $ DESTINATION_PT_CODE: int  10051 10051 90079 90079 17229 20141 20141 10017 70161 70161 ...\n $ TOTAL_TRIPS        : int  3 5 3 5 4 1 24 2 1 7 ...\n```\n:::\n:::\n\n:::\n\nBased on the data frame structures seen above, `ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` are listed as integer variables, though they are categorical in nature. As such, they should be transformed to factors so that R treats them as a grouping variable. Additionally, the length of the integer variables are a mixture of 4 and 5 numeric characters. However, bus stops in Singapore are identifiable via a 5-digit bus stop code. As such, we will need to standardise the variable length. \n\n::: panel-tabset\n### August 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Columns to convert to factors\ncolumns_to_convert <- c(\"ORIGIN_PT_CODE\", \"DESTINATION_PT_CODE\")\n\n# Ensure length of 5 characters for specific columns\nodbus_202308[columns_to_convert] <- lapply(odbus_202308[columns_to_convert], function(x) {\n  sprintf(\"%05d\", x)\n})\n\n# Apply as.factor() to the adjusted columns\nodbus_202308[columns_to_convert] <- lapply(odbus_202308[columns_to_convert], as.factor)\n\n# Re-examine the structure of the data frame\nstr(odbus_202308)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5709512 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-08\" \"2023-08\" \"2023-08\" \"2023-08\" ...\n $ DAY_TYPE           : chr  \"WEEKDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  16 16 14 14 17 17 17 17 7 17 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : Factor w/ 5067 levels \"01012\",\"01013\",..: 104 104 4422 4422 2008 2008 832 832 779 355 ...\n $ DESTINATION_PT_CODE: Factor w/ 5071 levels \"01012\",\"01013\",..: 239 239 4736 4736 691 691 807 807 234 107 ...\n $ TOTAL_TRIPS        : int  7 2 3 10 5 4 3 22 3 3 ...\n```\n:::\n:::\n\n\n### September 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure length of 5 characters for specific columns\nodbus_202309[columns_to_convert] <- lapply(odbus_202309[columns_to_convert], function(x) {\n  sprintf(\"%05d\", x)\n})\n\n# Apply as.factor() to the adjusted columns\nodbus_202309[columns_to_convert] <- lapply(odbus_202309[columns_to_convert], as.factor)\n\n# Re-examine the structure of the data frame\nstr(odbus_202309)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5714196 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-09\" \"2023-09\" \"2023-09\" \"2023-09\" ...\n $ DAY_TYPE           : chr  \"WEEKENDS/HOLIDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  17 10 10 7 7 11 16 16 16 20 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : Factor w/ 5067 levels \"01012\",\"01013\",..: 1201 3608 3608 1154 1154 2726 67 2866 2866 1906 ...\n $ DESTINATION_PT_CODE: Factor w/ 5072 levels \"01012\",\"01013\",..: 1008 3598 3598 1125 1125 1793 354 2777 2777 515 ...\n $ TOTAL_TRIPS        : int  1 9 2 6 1 2 18 3 2 1 ...\n```\n:::\n:::\n\n\n### October 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure length of 5 characters for specific columns\nodbus_202310[columns_to_convert] <- lapply(odbus_202310[columns_to_convert], function(x) {\n  sprintf(\"%05d\", x)\n})\n\n# Apply as.factor() to the adjusted columns\nodbus_202310[columns_to_convert] <- lapply(odbus_202310[columns_to_convert], as.factor)\n\n# Re-examine the structure of the data frame\nstr(odbus_202310)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5694297 obs. of  7 variables:\n $ YEAR_MONTH         : chr  \"2023-10\" \"2023-10\" \"2023-10\" \"2023-10\" ...\n $ DAY_TYPE           : chr  \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : int  16 16 14 14 17 17 17 7 14 14 ...\n $ PT_TYPE            : chr  \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : Factor w/ 5073 levels \"01012\",\"01013\",..: 105 105 4428 4428 2011 834 834 781 4462 4462 ...\n $ DESTINATION_PT_CODE: Factor w/ 5077 levels \"01012\",\"01013\",..: 240 240 4742 4742 693 809 809 235 4002 4002 ...\n $ TOTAL_TRIPS        : int  3 5 3 5 4 1 24 2 1 7 ...\n```\n:::\n:::\n\n:::\n\n## Extract Commuting Flow data\n\nThe code chunk below creates a function to extract commuting flows for the 4 target time periods. After extracting the commuting flow, the function will check for missing Bus Stops against the `BusStop` data set, and impute a value of `0` if so. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a function that takes in two inputs to extract commuting flow\n# data -- Input odbus data\n# BusStopList -- Input full list of bus stops for checking\ncommuting_flow <- function(data, BusStopList) {\n  \n  # Extract commuting flow for weekday morning peak\n  weekday_morn <- data %>%\n    filter(DAY_TYPE == \"WEEKDAY\") %>%\n    filter(TIME_PER_HOUR >= 6 & TIME_PER_HOUR <=9) %>%\n    group_by(ORIGIN_PT_CODE) %>%\n    summarise(TRIPS = sum(TOTAL_TRIPS)) %>%\n    mutate(SOURCE = \"weekday morning\")\n  \n  # Identify missing Bus Stops and impute a 0 value\n  weekday_morn_missing <- BusStopList %>%\n    anti_join(weekday_morn, by = \"ORIGIN_PT_CODE\") %>%\n    mutate(TRIPS = 0) %>%\n    mutate(SOURCE = \"weekday morning\")\n  \n  # Extract commuting flow for weekday evening peak\n  weekday_evening <- data %>%\n    filter(DAY_TYPE == \"WEEKDAY\") %>%\n    filter(TIME_PER_HOUR >= 17 & TIME_PER_HOUR <= 20) %>%\n    group_by(ORIGIN_PT_CODE) %>%\n    summarise(TRIPS = sum(TOTAL_TRIPS))%>%\n    mutate(SOURCE = \"weekday evening\")\n  \n  # Identify missing Bus Stops and impute a 0 value\n  weekday_evening_missing <- BusStopList %>%\n    anti_join(weekday_evening, by = \"ORIGIN_PT_CODE\") %>%\n    mutate(TRIPS = 0) %>%\n    mutate(SOURCE = \"weekday evening\")\n  \n  # Extract commuting flow for weekend morning peak\n  weekend_morn <- data %>%\n    filter(DAY_TYPE == \"WEEKENDS/HOLIDAY\") %>%\n    filter(TIME_PER_HOUR >= 11 & TIME_PER_HOUR <= 14) %>%\n    group_by(ORIGIN_PT_CODE) %>%\n    summarise(TRIPS = sum(TOTAL_TRIPS))%>%\n    mutate(SOURCE = \"weekend morning\")\n  \n  # Identify missing Bus Stops and impute a 0 value\n  weekend_morn_missing <- BusStopList %>%\n    anti_join(weekend_morn, by = \"ORIGIN_PT_CODE\") %>%\n    mutate(TRIPS = 0) %>%\n    mutate(SOURCE = \"weekend morning\")\n  \n  # Extract commuting flow for weekend evening peak\n  weekend_evening <- data %>%\n    filter(DAY_TYPE == \"WEEKENDS/HOLIDAY\") %>%\n    filter(TIME_PER_HOUR >= 16 & TIME_PER_HOUR <= 19) %>%\n    group_by(ORIGIN_PT_CODE) %>%\n    summarise(TRIPS = sum(TOTAL_TRIPS))%>%\n    mutate(SOURCE = \"weekend evening\")\n  \n  # Identify missing Bus Stops and impute a 0 value\n  weekend_evening_missing <- BusStopList %>%\n    anti_join(weekend_evening, by = \"ORIGIN_PT_CODE\") %>%\n    mutate(TRIPS = 0) %>%\n    mutate(SOURCE = \"weekend evening\")\n  \n  # Combine the data frames\n  result <- rbind(weekday_morn, weekday_morn_missing, \n                  weekday_evening, weekday_evening_missing, \n                  weekend_morn, weekend_morn_missing,\n                  weekend_evening, weekend_evening_missing)\n  \n  return(result)\n}\n```\n:::\n\n\nThe function can then be applied to each month's `odbus` data frame to extract commuting flows for the 4 target time periods within each month.\n\n::: panel-tabset\n### August 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a list of full Bus Stop codes for checking\nBusStopList <- data.frame(ORIGIN_PT_CODE = BusStop$BUS_STOP_N)\n\nodbus_202308_commuterflow <- commuting_flow(odbus_202308, BusStopList)\n```\n:::\n\n\nThe code chunk below will be used to check that all bus stops have four rows of data (i.e. weekday morning, weekday evening, weekend morning and weekend evening). If there are any bus stops with less than four rows of data, the Bus Stop codes will be printed and checked against the list of full Bus Stop codes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202308_check <- odbus_202308_commuterflow %>%\n  count(ORIGIN_PT_CODE) %>%\n  filter(n < 4) \n\nresult_202308 <- odbus_202308_commuterflow %>%\n  mutate(Message = ifelse(ORIGIN_PT_CODE %in% BusStopList$ORIGIN_PT_CODE, \n                          \"\", \"cannot be found\")) %>%\n  filter(Message == \"cannot be found\") %>%\n  select(ORIGIN_PT_CODE, Message) %>%\n  unique()\n\nprint(result_202308)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 54 × 2\n   ORIGIN_PT_CODE Message        \n   <fct>          <chr>          \n 1 03361          cannot be found\n 2 03549          cannot be found\n 3 03579          cannot be found\n 4 04331          cannot be found\n 5 14529          cannot be found\n 6 14539          cannot be found\n 7 18111          cannot be found\n 8 41161          cannot be found\n 9 44099          cannot be found\n10 44931          cannot be found\n# … with 44 more rows\n```\n:::\n:::\n\n\nA search online shows that some of these can be clearly identified as new bus stops. Given that our geospatial data for bus stop locations is last updated in July 2023 while our aspatial passenger volume data is from August to October 2023, this could be a possible explanation for why some of the bus stops cannot be found in the geospatial data. \n\nGiven that these bus stops cannot be located within the geospatial data, we will drop these Bus Stops from our analysis. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202308_final <- odbus_202308_commuterflow %>%\n  anti_join(odbus_202308_check, by = \"ORIGIN_PT_CODE\")\n\nstr(odbus_202308_final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [20,760 × 3] (S3: tbl_df/tbl/data.frame)\n $ ORIGIN_PT_CODE: Factor w/ 5199 levels \"01012\",\"01013\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ TRIPS         : num [1:20760] 1973 952 1789 2561 2938 ...\n $ SOURCE        : chr [1:20760] \"weekday morning\" \"weekday morning\" \"weekday morning\" \"weekday morning\" ...\n```\n:::\n:::\n\n\n### September 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202309_commuterflow <- commuting_flow(odbus_202309, BusStopList)\n```\n:::\n\n\nThe code chunk below will be used to check that all bus stops have four rows of data (i.e. weekday morning, weekday evening, weekend morning and weekend evening). If there are any bus stops with less than four rows of data, the Bus Stop codes will be printed and checked against the list of full Bus Stop codes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202309_check <- odbus_202309_commuterflow %>%\n  count(ORIGIN_PT_CODE) %>%\n  filter(n < 4) \n\nresult_202309 <- odbus_202309_check %>%\n  mutate(Message = ifelse(ORIGIN_PT_CODE %in% BusStopList$ORIGIN_PT_CODE, \n                          \"\", \"cannot be found\"))\n\nprint(result_202309)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  ORIGIN_PT_CODE     n Message        \n  <fct>          <int> <chr>          \n1 03549              2 cannot be found\n2 14521              3 cannot be found\n3 68181              2 cannot be found\n4 68189              2 cannot be found\n5 68191              1 cannot be found\n6 68199              1 cannot be found\n7 96461              3 cannot be found\n8 96471              3 cannot be found\n9 96479              3 cannot be found\n```\n:::\n:::\n\n\nGiven that these bus stops cannot be located within the geospatial data, we will drop these Bus Stops from our analysis. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202309_final <- odbus_202309_commuterflow %>%\n  anti_join(odbus_202309_check, by = \"ORIGIN_PT_CODE\")\n\nstr(odbus_202309_final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [20,760 × 3] (S3: tbl_df/tbl/data.frame)\n $ ORIGIN_PT_CODE: Factor w/ 5199 levels \"01012\",\"01013\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ TRIPS         : num [1:20760] 1640 764 1322 2373 2562 ...\n $ SOURCE        : chr [1:20760] \"weekday morning\" \"weekday morning\" \"weekday morning\" \"weekday morning\" ...\n```\n:::\n:::\n\n\n### October 2023 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202310_commuterflow <- commuting_flow(odbus_202310, BusStopList)\n```\n:::\n\n\nThe code chunk below will be used to check that all bus stops have four rows of data (i.e. weekday morning, weekday evening, weekend morning and weekend evening). If there are any bus stops with less than four rows of data, the Bus Stop codes will be printed and checked against the list of full Bus Stop codes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202310_check <- odbus_202310_commuterflow %>%\n  count(ORIGIN_PT_CODE) %>%\n  filter(n < 4) \n\nresult_202310 <- odbus_202310_check %>%\n  mutate(Message = ifelse(ORIGIN_PT_CODE %in% BusStopList$ORIGIN_PT_CODE, \n                          \"\", \"cannot be found\"))\n\nprint(result_202310)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   ORIGIN_PT_CODE     n Message        \n   <fct>          <int> <chr>          \n 1 03549              3 cannot be found\n 2 14521              3 cannot be found\n 3 44711              2 cannot be found\n 4 68181              2 cannot be found\n 5 68189              2 cannot be found\n 6 68191              2 cannot be found\n 7 68199              2 cannot be found\n 8 96461              3 cannot be found\n 9 96471              3 cannot be found\n10 96479              3 cannot be found\n```\n:::\n:::\n\n\nGiven that these bus stops cannot be located within the geospatial data, we will drop these Bus Stops from our analysis. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nodbus_202310_final <- odbus_202310_commuterflow %>%\n  anti_join(odbus_202310_check, by = \"ORIGIN_PT_CODE\")\n\nstr(odbus_202310_final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [20,780 × 3] (S3: tbl_df/tbl/data.frame)\n $ ORIGIN_PT_CODE: Factor w/ 5205 levels \"01012\",\"01013\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ TRIPS         : num [1:20780] 1770 841 1530 2483 2919 ...\n $ SOURCE        : chr [1:20780] \"weekday morning\" \"weekday morning\" \"weekday morning\" \"weekday morning\" ...\n```\n:::\n:::\n\n:::\n\n## Append Commuting Flow data with Bus Stop Locations\n\n`left_join()` of **dplyr** is used to join the geographical data and commuting flow data table using County as the common identifier. Left join is done to ensure that the geospatial properties (geometry column) of the `BusStop` sf data frame is retained. After the join, a pipe operation is done to convert NA values into 0 -- this ensures that the entire geographical area of Singapore can be seen on the resultant map output. \n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin_BusStop_202308 <- left_join(BusStop, odbus_202308_commuterflow,\n                                   by = c(\"BUS_STOP_N\" = \"ORIGIN_PT_CODE\")) %>%\n  mutate(`TRIPS` = ifelse(is.na(`TRIPS`), 0, `TRIPS`))\n```\n:::\n\n\nCheck for any duplicates using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicate <- origin_BusStop_202308 %>%\n  group_by_all() %>%\n  filter(n()>1) %>%\n  ungroup()\n\nduplicate\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 0 features and 5 fields\nBounding box:  xmin: NA ymin: NA xmax: NA ymax: NA\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 0 × 6\n# … with 6 variables: BUS_STOP_N <chr>, BUS_ROOF_N <chr>, LOC_DESC <chr>,\n#   TRIPS <dbl>, SOURCE <chr>, geometry <GEOMETRY [m]>\n```\n:::\n:::\n\n\n`cellsize` argument is the cell size, in the units that the crs of the spatial data is using. Since the data is set in SVY21 projected coordinate system, which [uses metres as the unit](https://epsg.io/3414), the value is set as `c(250,250)` to create a hexagon layer of 250m.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narea_honeycomb_grid = st_make_grid(origin_BusStop_202308, c(250, 250), what = \"point\", square = FALSE)\n\n# To sf and add grid ID\nhoneycomb_grid_sf = st_sf(area_honeycomb_grid) %>%\n  # add grid ID\n  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))\n\n# count number of points in each grid\n# https://gis.stackexchange.com/questions/323698/counting-points-in-polygons-with-sf-package-of-r\nhoneycomb_grid_sf$TOT_TRIPS = lengths(st_intersects(honeycomb_grid_sf, origin_BusStop_202308))\n\n# remove grid without value of 0 (i.e. no points in side that grid)\nhoneycomb_count = filter(honeycomb_grid_sf, TOT_TRIPS > 0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap_honeycomb = tm_shape(honeycomb_count) +\n  tm_fill(\n    col = \"TOT_TRIPS\",\n    palette = \"Blues\",\n    style = \"cont\",\n    title = \"Number of trips\",\n    id = \"grid_id\",\n    showNA = FALSE,\n    alpha = 0.6,\n    popup.vars = c(\n      \"Number of trips: \" = \"TOT_TRIPS\"\n    ),\n    popup.format = list(\n      TOT_TRIPS = list(format = \"f\", digits = 0)\n    )\n  ) +\n  tm_borders(col = \"grey40\", lwd = 0.7)\nmap_honeycomb\n```\n\n::: {.cell-output-display}\n![](Take_home_Ex1_files/figure-html/unnamed-chunk-23-1.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "Take_home_Ex1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}