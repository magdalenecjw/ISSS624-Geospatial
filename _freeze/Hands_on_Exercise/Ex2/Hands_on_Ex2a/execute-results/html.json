{
  "hash": "bb4b35e9372c5204a84d4466b30c7cc2",
  "result": {
    "markdown": "---\ntitle: \"2a: Spatial Weights and Applications\"\nauthor: \"Magdalene Chan\"\ndate: 2023-11-18\ndate-modified: \"last-modified\"\nexecute: \n  warning: false\n---\n\n\n**Spatial weights** (W~ij~) are a way to define spatial neighbourhoods.\n\n## Getting Started\n\nThe code chunk below uses p_load() of pacman package to check if the required packages have been installed on the computer. If they are, the packages will be launched.\n\n-   **sf** package is used for importing, managing, and processing geospatial data.\n-   **tmap** package is used for thematic mapping.\n-   **spdep** package is used to create spatial weights matrix objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n\nThe data sets used are:\n\n-   Hunan county boundary layer: a geospatial data set in ESRI shapefile format.\n-   Hunan_2012.csv: csv file that contains selected Hunan's local development indicators in 2012.\n\n## Importing Data\n\n### Import shapefile into R\n\nThe code chunk below uses the `st_read()` function of **sf** package to import Hunan county boundary shapefile into R as a simple feature data frame called `hunan`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\magdalenecjw\\ISSS624 Geospatial\\Hands_on_Exercise\\Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nThere are a total of 88 polygon features and 7 fields in `hunan` simple feature data frame. `hunan` is in **wgs84** GCS.\n\n### Import aspatial data into R\n\nThe code chunk below uses the `read_csv()` function of **readr** package to import `Hunan_2012.csv` file into R and save it as a R dataframe called `hunan2012`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n### Performing relational join\n\n`left_join()` of **dplyr** is used to join the geographical data and attribute table using `County` as the common identifier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012)%>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n## Visualising Regional Development Indicator\n\nPrepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using `qtm()` of **tmap** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands_on_Ex2a_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n> The choropleth map generated is based on equal intervals. All except nine regions have a GDPPC of either \"0 to 20,000\" or \"20,000 to 40,000\" -- the distribution of GDPPC appears to be right-skewed.\n\n## Computing Contiguity Spatial Weights\n\n`poly2nb()` of **spdep** package computes contiguity weight matrices for the study area by building a neighbours list based on regions with contiguous boundaries.\n\nContiguity means that two spatial units share a common border of non-zero length. \nThis can be further divided into rook, bishop or queen criterion of contiguity, in analogy to the moves allowed for the such-named pieces on a chess board.\n\nThe **rook** criterion defines neighbors by the existence of a common edge between two spatial units, while the **bishop** criterion by the existence of a common vertex. The **queen** criterion defines neighbors as spatial units sharing a common edge **or** a common vertex -- hence, the number of neighbors according to the queen criterion will always be larger than or equal to the rook or bishop criterion.\n\n> In `poly2nb()`, the `queen` argument takes `TRUE` (default) or `FALSE` as options.\n\n### Compute (queen) contiguity based neighbours\n\nThe code chunk below computes the queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nBased on the summary report above, there are 88 area units in Hunan. The most connected area unit has 11 neighbours while there are two area units with only one neighbour each. \n\nFor each polygon in the polygon object, `wm_q` lists all neighboring polygons. The code chunk below can be used to see the neighbors for the first polygon in the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]] # <1>\nhunan$County[1] # <2>\nhunan$NAME_3[c(2,3,4,57,85)] # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4 57 85\n[1] \"Anxiang\"\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n:::\n:::\n\n1. Show the neighbors for the first polygon in the object. Each number shown represents 1 polygon ID stored in `hunan` **SpatialPolygonsDataFrame** class.\n2. Retrieve the county name of Polygon ID=1.\n3. Retrieve the county names of the five neighboring polygons.\n",
    "supporting": [
      "Hands_on_Ex2a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}