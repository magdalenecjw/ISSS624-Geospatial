---
title: "1b: Emerging Hot Spot Analysis"
author: "Magdalene Chan"
date: 2023-11-25
date-modified: "last-modified"
execute: 
  warning: false
  freeze: auto
format:
  html:
    code-fold: true
---

# Tasks

This document continues on with the following task for the [Geospatial Analytics for Public Good study](https://geospatial2023.netlify.app/take_home_exercise/ex1/take_home_ex1). 

## Emerging Hot Spot Analysis

With reference to the passenger trips generated by origin at the hexagon level for the four time periods given above:

1.  Perform Mann-Kendall Test by using the spatio-temporal local G~i~\* values,
2.  Prepare EHSA maps of the G~i~\* values of the passenger trips by origin at the hexagon level. The maps should only display the significant (i.e. p-value \< 0.05).
3.  With reference to the EHSA maps and data visualisation prepared, describe the spatial patterns revealed (not more than 250 words per cluster).

# Getting Started

The code chunk below uses `p_load()` of `pacman` package to check if the required packages have been installed on the computer. If they are, the packages will be launched. The following packages will be used:

-   `sf` package is used for importing, managing, and processing geospatial data.
-   `sfdep` package is used to create spatial weights matrix and LISA objects using the sf class to represent spatial data.
-   `tmap` package is used for thematic mapping.
-   `plotly` package is used to create interactive graphs and charts. 
-   `tidyverse` package is used for aspatial data wrangling.
-   `knitr` package is used for dynamic report generation in R. 

```{r}
pacman::p_load(sf, sfdep, tmap, plotly, tidyverse, knitr)
```

# Import rds file

The code chunk below is used to import `hex_grid` and `hex_grid_count` rds files generated and saved in the [first half of this study](https://geospatial2023.netlify.app/take_home_exercise/ex1/take_home_ex1) into the R environment.

```{r}
hex_grid <- read_rds("data/rds/hex_grid.rds")
hex_grid_count <- read_rds("data/rds/hex_grid_count.rds")
```

# Emerging Hotspot Analysis

## Time Series Cube

Spatio-temporal data are typically presented in long formats, where a row identifies a unique location and time observation represented by a column dedicated to time and another to locations. However, such data are traditionally not linked to the geographies as they contain only an identifier of the location, but not the spatial representation that makes the data meaningful for geospatial analysis. 

The `spacetime` class in **sfdep** package can be used to create lattice data that is a representation of spatio-temporal data for a set of regions containing the geometries over a number of different time-periods. There are two possible layouts: spatio-temporal full grid and sparse grids.

Given a number of spatial features `n`, and time periods `m`, a **spatio-temporal full grid** contains `nÃ—m` rows. Each location has a recorded observation for each of the time periods in `m`. When there are missing observations for some locations or time periods and they are entirely omitted from the data set, that is a **spatio-temporal sparse grid**.

For this analysis, time series cubes will be created for each of the four target time periods respectively using the earlier created `hex_grid_count`.

## Create Time Series Cube

In the code chunks below, relevant columns that correspond to the target time periods will be selected from `hex_grid_count` and joined with `hex_grid` to create the `n` number of spatial features. The corresponding sf data frame will then be pivoted longer to create a time series data containing the `m` time periods. Once the data frame has `nxm` rows, apply the `spacetime()` function to create the time series cube. 

:::panel-tabset
### Weekday Morning Time Series Cube

```{r}
# Select relevant columns from hex_grid_count
weekday_morn_hex <- hex_grid_count %>%
  select(index, count, bus_stop_codes, bus_stop_names, geometry,
         `WEEKDAY 6`, `WEEKDAY 7`, `WEEKDAY 8`, `WEEKDAY 9`)

# Join with hex_grid and pivot longer to create time series data
weekday_morn_full <- st_join(hex_grid, weekday_morn_hex, join = st_within) %>%
  select(-c(index.y)) %>%
  rename(index = index.x) %>%
  rename_with(~gsub("WEEKDAY ", "", .), matches("^WEEKDAY \\d+$")) %>%
  pivot_longer(cols = c(`6`, `7`, `8`, `9`), 
               names_to = "TIME_PER_HOUR", values_to = "TRIPS",
               names_transform = as.integer, values_transform = as.integer) %>%
  mutate(across(where(is.integer), ~ifelse(is.na(.), 0, .)))

# Apply spacetime() function
weekday_morn_cube <- spacetime(weekday_morn_full, hex_grid,
                               .loc_col = "index", .time_col = "TIME_PER_HOUR")

# Verify that resultant output is a spacetime cube
is_spacetime_cube(weekday_morn_cube)
```

The `TRUE` return confirms that `weekday_morn_cube` object is indeed an time-space cube.

### Weekday Evening Time Series Cube

```{r}
# Select relevant columns from hex_grid_count
weekday_evening_hex <- hex_grid_count %>%
  select(index, count, bus_stop_codes, bus_stop_names, geometry,
         `WEEKDAY 17`, `WEEKDAY 18`, `WEEKDAY 19`, `WEEKDAY 20`)

# Join with hex_grid and pivot longer to create time series data
weekday_evening_full <- st_join(hex_grid, weekday_evening_hex, join = st_within) %>%
  select(-c(index.y)) %>%
  rename(index = index.x) %>%
  rename_with(~gsub("WEEKDAY ", "", .), matches("^WEEKDAY \\d+$")) %>%
  pivot_longer(cols = c(`17`, `18`, `19`, `20`), 
               names_to = "TIME_PER_HOUR", values_to = "TRIPS",
               names_transform = as.integer, values_transform = as.integer) %>%
  mutate(across(where(is.integer), ~ifelse(is.na(.), 0, .)))

# Apply spacetime() function
weekday_evening_cube <- spacetime(weekday_evening_full, hex_grid,
                               .loc_col = "index", .time_col = "TIME_PER_HOUR")

# Verify that resultant output is a spacetime cube
is_spacetime_cube(weekday_evening_cube)
```

The `TRUE` return confirms that `weekday_evening_cube` object is indeed an time-space cube.

### Weekend/PH Morning Time Series Cube

```{r}
# Select relevant columns from hex_grid_count
weekend_morn_hex <- hex_grid_count %>%
  select(index, count, bus_stop_codes, bus_stop_names, geometry,
         `WEEKENDS/HOLIDAY 11`, `WEEKENDS/HOLIDAY 12`, 
         `WEEKENDS/HOLIDAY 13`, `WEEKENDS/HOLIDAY 14`)

# Join with hex_grid and pivot longer to create time series data
weekend_morn_full <- st_join(hex_grid, weekend_morn_hex, join = st_within) %>%
  select(-c(index.y)) %>%
  rename(index = index.x) %>%
  rename_with(~gsub("WEEKENDS/HOLIDAY ", "", .), matches("^WEEKENDS/HOLIDAY \\d+$")) %>%
  pivot_longer(cols = c(`11`, `12`, `13`, `14`), 
               names_to = "TIME_PER_HOUR", values_to = "TRIPS",
               names_transform = as.integer, values_transform = as.integer) %>%
  mutate(across(where(is.integer), ~ifelse(is.na(.), 0, .)))

# Apply spacetime() function
weekend_morn_cube <- spacetime(weekend_morn_full, hex_grid,
                               .loc_col = "index", .time_col = "TIME_PER_HOUR")

# Verify that resultant output is a spacetime cube
is_spacetime_cube(weekend_morn_cube)
```

The `TRUE` return confirms that `weekend_morn_cube` object is indeed an time-space cube.

### Weekend/PH Evening Time Series Cube

```{r}
# Select relevant columns from hex_grid_count
weekend_evening_hex <- hex_grid_count %>%
  select(index, count, bus_stop_codes, bus_stop_names, geometry,
         `WEEKENDS/HOLIDAY 16`, `WEEKENDS/HOLIDAY 17`, 
         `WEEKENDS/HOLIDAY 18`, `WEEKENDS/HOLIDAY 19`)

# Join with hex_grid and pivot longer to create time series data
weekend_evening_full <- st_join(hex_grid, weekend_evening_hex, join = st_within) %>%
  select(-c(index.y)) %>%
  rename(index = index.x) %>%
  rename_with(~gsub("WEEKENDS/HOLIDAY ", "", .), matches("^WEEKENDS/HOLIDAY \\d+$")) %>%
  pivot_longer(cols = c(`16`, `17`, `18`, `19`), 
               names_to = "TIME_PER_HOUR", values_to = "TRIPS",
               names_transform = as.integer, values_transform = as.integer) %>%
  mutate(across(where(is.integer), ~ifelse(is.na(.), 0, .)))

# Apply spacetime() function
weekend_evening_cube <- spacetime(weekend_evening_full, hex_grid,
                               .loc_col = "index", .time_col = "TIME_PER_HOUR")

# Verify that resultant output is a spacetime cube
is_spacetime_cube(weekend_evening_cube)
```

The `TRUE` return confirms that `weekend_evening_cube` object is indeed an time-space cube.
:::

## Computation of Local G~i~* statistics

To compute the local G~i~* statistics, spatial weights must first be derived. The code chunks below will be used to identify neighbors and to derive an inverse distance weights for each target time period. `activate()` is used to first activate the geometry context, followed by 
`mutate()` to create two new columns `nb` and `wt`. Then activate the data context again and copy over the `nb` and `wt` columns to each time-slice using `set_nbs()` and `set_wts()`.

:::panel-tabset
### Spatial Weights for Weekday Morning

```{r}
weekday_morn_nb <- weekday_morn_cube %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

### Spatial Weights for Weekday Evening

```{r}
weekday_evening_nb <- weekday_evening_cube %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

### Spatial Weights for Weekend/PH Morning

```{r}
weekend_morn_nb <- weekend_morn_cube %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

### Spatial Weights for Weekend/PH Evening

```{r}
weekend_evening_nb <- weekend_evening_cube %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```
:::

In the code chunks below, the new columns are used to manually calculate the local G~i~* for each location. This is done by grouping by `TIME_PER_HOUR` and using `local_gstar_perm()` of sfdep package. After which, `unnest()` is used to unnest the `gi_star` column of the newly created output. 

:::panel-tabset
### G~i~* for Weekday Morning
```{r}
gi_weekday_morn <- weekday_morn_nb %>%
  group_by(TIME_PER_HOUR) %>%
  mutate(gi_star = local_gstar_perm(TRIPS, nb, wt)) %>%
  tidyr::unnest(gi_star)
```

### G~i~* for Weekday Evening
```{r}
gi_weekday_evening <- weekday_evening_nb %>%
  group_by(TIME_PER_HOUR) %>%
  mutate(gi_star = local_gstar_perm(TRIPS, nb, wt)) %>%
  tidyr::unnest(gi_star)
```

### G~i~* for Weekend/PH Morning
```{r}
gi_weekend_morn <- weekend_morn_nb %>%
  group_by(TIME_PER_HOUR) %>%
  mutate(gi_star = local_gstar_perm(TRIPS, nb, wt)) %>%
  tidyr::unnest(gi_star)
```

### G~i~* for Weekend/PH Evening
```{r}
gi_weekend_evening <- weekend_evening_nb %>%
  group_by(TIME_PER_HOUR) %>%
  mutate(gi_star = local_gstar_perm(TRIPS, nb, wt)) %>%
  tidyr::unnest(gi_star)
```
:::

## Mann-Kendall Test

With the computed G~i~* statistics, each location can be evaluated for trends using the Mann-Kendall Test. 

:::panel-tabset

### Mann-Kendall Test for Weekday Morning
```{r}
ehsa_weekday_morn <- gi_weekday_morn %>%
  group_by(index) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots using the code chunk below:

```{r}
emerging_weekday_morn <- ehsa_weekday_morn %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
```

### Mann-Kendall Test for Weekday Evening
```{r}
ehsa_weekday_evening <- gi_weekday_evening %>%
  group_by(index) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots using the code chunk below:

```{r}
emerging_weekday_evening <- ehsa_weekday_evening %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
```

### Mann-Kendall Test for Weekend/PH Morning
```{r}
ehsa_weekend_morn <- gi_weekend_morn %>%
  group_by(index) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots using the code chunk below:

```{r}
emerging_weekend_morn <- ehsa_weekend_morn %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
```

### Mann-Kendall Test for Weekend/PH Evening
```{r}
ehsa_weekend_evening <- gi_weekend_evening %>%
  group_by(index) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)
```

Arrange to show significant emerging hot/cold spots using the code chunk below:

```{r}
emerging_weekend_evening <- ehsa_weekend_evening %>% 
  arrange(sl, abs(tau)) %>% 
  slice(1:5)
```
:::


